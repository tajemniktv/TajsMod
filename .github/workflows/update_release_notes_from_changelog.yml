name: Update GitHub Release Notes from CHANGELOG

on:
  push:
    branches: ["master"]
    paths:
      - "CHANGELOG.md"
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  update_notes:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Update release notes for affected versions
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail

          test -f CHANGELOG.md || (echo "Missing CHANGELOG.md" && exit 1)

          # --- SAFE_ID from manifest (for SAFE_ID-vX.Y.Z tags) ---
          MANIFEST="$(git ls-files | grep -E '(^|/)manifest\.json$' | head -n 1 || true)"
          test -n "$MANIFEST" || (echo "No manifest.json found in repo" && exit 1)

          NAMESPACE="$(jq -r '.namespace // empty' "$MANIFEST")"
          NAME="$(jq -r '.name // empty' "$MANIFEST")"
          test -n "$NAME" || (echo "manifest.json: missing .name" && exit 1)

          if [ -n "$NAMESPACE" ]; then MOD_ID="${NAMESPACE}-${NAME}"; else MOD_ID="${NAME}"; fi
          SAFE_ID="$(echo "$MOD_ID" | tr ' ' '-' | tr -cd '[:alnum:]._-' )"

          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.sha }}"
          if [[ "$BEFORE" =~ ^0+$ ]]; then
            BEFORE="$(git rev-parse "${AFTER}~1")"
          fi

          DIFF_FILE="$(mktemp)"
          git diff --unified=0 "$BEFORE" "$AFTER" -- CHANGELOG.md > "$DIFF_FILE" || true

          CHANGED_LINES="$(mktemp)"
          # Extract "new file" (+c,d) line ranges from unified diff hunks -> list of changed line numbers in new file
          awk '
            match($0,/^@@ -[0-9]+(,[0-9]+)? \+([0-9]+)(,([0-9]+))? @@/,m) {
              start=m[2]
              count=(m[4] ? m[4] : 1)
              for (i=0; i<count; i++) print start+i
            }
          ' "$DIFF_FILE" | sort -n | uniq > "$CHANGED_LINES"

          if [ ! -s "$CHANGED_LINES" ]; then
            echo "No changed line ranges detected; nothing to update."
            exit 0
          fi

          # Map changed line numbers -> closest version header above in CHANGELOG.md
          VERSIONS="$(
            awk -v lines_file="$CHANGED_LINES" '
              BEGIN {
                while ((getline l < lines_file) > 0) changed[l]=1
                cur=""
              }
              {
                if (match($0, /^##[[:space:]]*\[([^]]+)\][[:space:]]*-/ , m)) {
                  cur=m[1]
                }
                if (cur != "" && changed[NR]) vers[cur]=1
              }
              END { for (v in vers) print v }
            ' CHANGELOG.md | sort -u
          )"

          if [ -z "$VERSIONS" ]; then
            echo "No affected versions detected; nothing to update."
            exit 0
          fi

          echo "Versions to update:"
          echo "$VERSIONS"

          extract_notes() {
            local ver="$1"
            awk -v ver="$ver" '
              BEGIN {found=0}
              $0 ~ "^##[[:space:]]*\\[" ver "\\][[:space:]]*-" {found=1; next}
              found && $0 ~ "^##[[:space:]]*\\[[0-9]" {exit}
              found {print}
            ' CHANGELOG.md
          }

          trim_notes() {
            awk '
              {a[NR]=$0}
              END{
                i=1
                while (i<=NR && a[i] ~ /^[[:space:]]*$/) i++
                j=NR
                while (j>=1 && a[j] ~ /^[[:space:]]*$/) j--
                for (k=i; k<=j; k++) print a[k]
              }'
          }

          for ver in $VERSIONS; do
            NOTES="$(extract_notes "$ver" | trim_notes)"

            if [ -z "$(printf "%s" "$NOTES" | tr -d '[:space:]')" ]; then
              echo "[v$ver] CHANGELOG section is empty -> skipping"
              continue
            fi

            # Support both tag styles:
            # 1) vX.Y.Z
            # 2) SAFE_ID-vX.Y.Z
            CAND1="v${ver}"
            CAND2="${SAFE_ID}-v${ver}"
            TAG=""

            if gh release view "$CAND1" >/dev/null 2>&1; then
              TAG="$CAND1"
            elif gh release view "$CAND2" >/dev/null 2>&1; then
              TAG="$CAND2"
            else
              # Fallback: find by release title (name)
              FOUND_TAG="$(gh release list --limit 200 --json name,tagName --jq \
                '.[] | select(.name=="v'"$ver"'" or .name=="'"$ver"'") | .tagName' | head -n 1 || true)"
              if [ -n "$FOUND_TAG" ]; then
                TAG="$FOUND_TAG"
              fi
            fi

            if [ -z "$TAG" ]; then
              echo "[v$ver] Release not found (no matching tag/title) -> skipping"
              continue
            fi

            tmp="$(mktemp)"
            printf "%s\n" "$NOTES" > "$tmp"

            echo "[$TAG] Updating release notes..."
            gh release edit "$TAG" --notes-file "$tmp"

            rm -f "$tmp"
          done

          rm -f "$DIFF_FILE" "$CHANGED_LINES"
