name: Update GitHub Release Notes from CHANGELOG

on:
  push:
    branches: ["master"]
    paths:
      - "CHANGELOG.md"
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  update_notes:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Update release notes for changed versions
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail

          test -f CHANGELOG.md || (echo "Missing CHANGELOG.md" && exit 1)

          # --- Determine SAFE_ID from manifest (for SAFE_ID-vX.Y.Z tags) ---
          MANIFEST="$(git ls-files | grep -E '(^|/)manifest\.json$' | head -n 1 || true)"
          test -n "$MANIFEST" || (echo "No manifest.json found in repo" && exit 1)

          NAMESPACE="$(jq -r '.namespace // empty' "$MANIFEST")"
          NAME="$(jq -r '.name // empty' "$MANIFEST")"
          test -n "$NAME" || (echo "manifest.json: missing .name" && exit 1)

          if [ -n "$NAMESPACE" ]; then MOD_ID="${NAMESPACE}-${NAME}"; else MOD_ID="${NAME}"; fi
          SAFE_ID="$(echo "$MOD_ID" | tr ' ' '-' | tr -cd '[:alnum:]._-' )"

          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.sha }}"

          # On the first commit on a new branch, "before" can be all zeros
          if [[ "$BEFORE" =~ ^0+$ ]]; then
            BEFORE="$(git rev-parse "${AFTER}~1")"
          fi

          DIFF="$(git diff --unified=0 "$BEFORE" "$AFTER" -- CHANGELOG.md || true)"

          # --- Detect which versions were affected, even if headers weren't edited ---
          VERSIONS="$(python3 - << 'PY'
import re, sys

diff = sys.stdin.read()

# Collect "new file" hunk ranges (+c,d) from unified diff headers
ranges = []
for m in re.finditer(r'^@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@', diff, re.M):
    start = int(m.group(1))
    count = int(m.group(2) or "1")
    if count > 0:
        ranges.append((start, start + count - 1))

if not ranges:
    print("")
    raise SystemExit(0)

# Map each line number in CHANGELOG.md to the latest version header above it
with open("CHANGELOG.md", "r", encoding="utf-8") as f:
    lines = f.readlines()

hdr = re.compile(r'^##\s*\[([^\]]+)\]\s*-')
line_to_ver = {}
current = None
for i, line in enumerate(lines, start=1):
    m = hdr.match(line)
    if m:
        current = m.group(1).strip()
    line_to_ver[i] = current

vers = set()
for a, b in ranges:
    for ln in range(a, b + 1):
        v = line_to_ver.get(ln)
        if v:
            vers.add(v)

print("\n".join(sorted(vers)))
PY
<<< "$DIFF")"

          if [ -z "$VERSIONS" ]; then
            echo "No affected versions detected; nothing to update."
            exit 0
          fi

          echo "Versions to update:"
          echo "$VERSIONS"

          # Helper: extract changelog section for a version
          extract_notes() {
            local ver="$1"
            awk -v ver="$ver" '
              BEGIN {found=0}
              $0 ~ "^##[[:space:]]*\\[" ver "\\][[:space:]]*-" {found=1; next}
              found && $0 ~ "^##[[:space:]]*\\[[0-9]" {exit}
              found {print}
            ' CHANGELOG.md
          }

          # Helper: trim leading/trailing blank lines
          trim_notes() {
            awk '
              {a[NR]=$0}
              END{
                i=1
                while (i<=NR && a[i] ~ /^[[:space:]]*$/) i++
                j=NR
                while (j>=1 && a[j] ~ /^[[:space:]]*$/) j--
                for (k=i; k<=j; k++) print a[k]
              }'
          }

          for ver in $VERSIONS; do
            NOTES="$(extract_notes "$ver" | trim_notes)"

            if [ -z "$(printf "%s" "$NOTES" | tr -d '[:space:]')" ]; then
              echo "[v$ver] CHANGELOG section is empty -> skipping"
              continue
            fi

            # Prefer tag = vX.Y.Z, fallback to SAFE_ID-vX.Y.Z
            CAND1="v${ver}"
            CAND2="${SAFE_ID}-v${ver}"
            TAG=""

            if gh release view "$CAND1" >/dev/null 2>&1; then
              TAG="$CAND1"
            elif gh release view "$CAND2" >/dev/null 2>&1; then
              TAG="$CAND2"
            else
              # Last resort: find by release title (name)
              FOUND_TAG="$(gh release list --limit 200 --json name,tagName --jq \
                '.[] | select(.name=="v'"$ver"'" or .name=="'"$ver"'") | .tagName' | head -n 1 || true)"
              if [ -n "$FOUND_TAG" ]; then
                TAG="$FOUND_TAG"
              fi
            fi

            if [ -z "$TAG" ]; then
              echo "[v$ver] Release not found (no matching tag/title) -> skipping"
              continue
            fi

            tmp="$(mktemp)"
            printf "%s\n" "$NOTES" > "$tmp"

            echo "[$TAG] Updating release notes from CHANGELOG.md..."
            gh release edit "$TAG" --notes-file "$tmp"

            rm -f "$tmp"
          done
